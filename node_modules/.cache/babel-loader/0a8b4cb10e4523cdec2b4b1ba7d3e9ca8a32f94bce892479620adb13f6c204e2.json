{"ast":null,"code":"class Typing {\n  constructor(ref, array) {\n    this.ref = ref.current;\n    this.newObj = [];\n    array.forEach((element, index) => {\n      this.newObj = [...this.newObj, element.split('')];\n    });\n    this.typing();\n  }\n  async typing() {\n    for (let arrayIndex = 0; arrayIndex < this.newObj.length; arrayIndex++) {\n      //초반 딜레이 줌.\n      if (arrayIndex === 0) {\n        await new Promise(resolve => {\n          setTimeout(() => {\n            resolve();\n          }, 2000);\n        });\n      }\n      await new Promise(resolve => {\n        for (let index = 0; index < this.newObj[arrayIndex].length; index++) {\n          setTimeout(() => {\n            let text = this.newObj[arrayIndex][index];\n            this.ref.textContent += text;\n          }, 50 * index);\n        }\n        setTimeout(() => {\n          resolve();\n        }, 50 * this.newObj[arrayIndex].length + 3500);\n      });\n      if (arrayIndex !== this.newObj.length - 1) {\n        await new Promise(resolve => {\n          for (let index = this.newObj[arrayIndex].length, i = 0; 0 < index; index--) {\n            setTimeout(() => {\n              this.newObj[arrayIndex].splice(index - 1, 1 + i);\n              this.ref.textContent = this.newObj[arrayIndex].join('');\n            }, 35 * i);\n            i++;\n          }\n          setTimeout(() => {\n            resolve();\n          }, 35 * this.newObj[arrayIndex].length + 1000);\n        });\n      } else {\n        this.ref.classList.add('cursorOff');\n      }\n    }\n  }\n}\nexport default Typing;","map":{"version":3,"names":["Typing","constructor","ref","array","current","newObj","forEach","element","index","split","typing","arrayIndex","length","Promise","resolve","setTimeout","text","textContent","i","splice","join","classList","add"],"sources":["C:/Users/Branden/Desktop/Branden/react_portfolio/src/components/Typing.js"],"sourcesContent":["\r\n\r\nclass Typing {\r\n    constructor(ref, array) {\r\n\r\n        this.ref = ref.current;\r\n        this.newObj = [];\r\n        array.forEach((element, index) => {\r\n            this.newObj = [...this.newObj, element.split('')];\r\n        });\r\n        this.typing();\r\n    }\r\n\r\n    async typing() {\r\n        for (let arrayIndex = 0; arrayIndex < this.newObj.length; arrayIndex++) {\r\n\r\n            //초반 딜레이 줌.\r\n            if (arrayIndex === 0) {\r\n                await new Promise(\r\n                    resolve => {\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, 2000);\r\n                    }\r\n                )\r\n            }\r\n            await new Promise(\r\n                resolve => {\r\n                    for (let index = 0; index < this.newObj[arrayIndex].length; index++) {\r\n                        setTimeout(() => {\r\n                            let text = this.newObj[arrayIndex][index];\r\n                            this.ref.textContent += text;\r\n                        }, 50 * index);\r\n                    }\r\n                    setTimeout(() => {\r\n                        resolve();\r\n                    }, 50 * this.newObj[arrayIndex].length + 3500);\r\n                }\r\n            )\r\n            if (arrayIndex !== this.newObj.length - 1) {\r\n                await new Promise(\r\n                    resolve => {\r\n                        for (let index = this.newObj[arrayIndex].length, i = 0; 0 < index; index--) {\r\n                            setTimeout(() => {\r\n                                this.newObj[arrayIndex].splice(index - 1, 1 + i);\r\n                                this.ref.textContent = this.newObj[arrayIndex].join('');\r\n                            }, 35 * i);\r\n                            i++\r\n                        }\r\n                        setTimeout(() => {\r\n                            resolve();\r\n                        }, 35 * this.newObj[arrayIndex].length + 1000);\r\n                    }\r\n                )\r\n            } else {\r\n                this.ref.classList.add('cursorOff');\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n\r\nexport default Typing;"],"mappings":"AAEA,MAAMA,MAAM,CAAC;EACTC,WAAWA,CAACC,GAAG,EAAEC,KAAK,EAAE;IAEpB,IAAI,CAACD,GAAG,GAAGA,GAAG,CAACE,OAAO;IACtB,IAAI,CAACC,MAAM,GAAG,EAAE;IAChBF,KAAK,CAACG,OAAO,CAAC,CAACC,OAAO,EAAEC,KAAK,KAAK;MAC9B,IAAI,CAACH,MAAM,GAAG,CAAC,GAAG,IAAI,CAACA,MAAM,EAAEE,OAAO,CAACE,KAAK,CAAC,EAAE,CAAC,CAAC;IACrD,CAAC,CAAC;IACF,IAAI,CAACC,MAAM,CAAC,CAAC;EACjB;EAEA,MAAMA,MAAMA,CAAA,EAAG;IACX,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,IAAI,CAACN,MAAM,CAACO,MAAM,EAAED,UAAU,EAAE,EAAE;MAEpE;MACA,IAAIA,UAAU,KAAK,CAAC,EAAE;QAClB,MAAM,IAAIE,OAAO,CACbC,OAAO,IAAI;UACPC,UAAU,CAAC,MAAM;YACbD,OAAO,CAAC,CAAC;UACb,CAAC,EAAE,IAAI,CAAC;QACZ,CACJ,CAAC;MACL;MACA,MAAM,IAAID,OAAO,CACbC,OAAO,IAAI;QACP,KAAK,IAAIN,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACH,MAAM,CAACM,UAAU,CAAC,CAACC,MAAM,EAAEJ,KAAK,EAAE,EAAE;UACjEO,UAAU,CAAC,MAAM;YACb,IAAIC,IAAI,GAAG,IAAI,CAACX,MAAM,CAACM,UAAU,CAAC,CAACH,KAAK,CAAC;YACzC,IAAI,CAACN,GAAG,CAACe,WAAW,IAAID,IAAI;UAChC,CAAC,EAAE,EAAE,GAAGR,KAAK,CAAC;QAClB;QACAO,UAAU,CAAC,MAAM;UACbD,OAAO,CAAC,CAAC;QACb,CAAC,EAAE,EAAE,GAAG,IAAI,CAACT,MAAM,CAACM,UAAU,CAAC,CAACC,MAAM,GAAG,IAAI,CAAC;MAClD,CACJ,CAAC;MACD,IAAID,UAAU,KAAK,IAAI,CAACN,MAAM,CAACO,MAAM,GAAG,CAAC,EAAE;QACvC,MAAM,IAAIC,OAAO,CACbC,OAAO,IAAI;UACP,KAAK,IAAIN,KAAK,GAAG,IAAI,CAACH,MAAM,CAACM,UAAU,CAAC,CAACC,MAAM,EAAEM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAGV,KAAK,EAAEA,KAAK,EAAE,EAAE;YACxEO,UAAU,CAAC,MAAM;cACb,IAAI,CAACV,MAAM,CAACM,UAAU,CAAC,CAACQ,MAAM,CAACX,KAAK,GAAG,CAAC,EAAE,CAAC,GAAGU,CAAC,CAAC;cAChD,IAAI,CAAChB,GAAG,CAACe,WAAW,GAAG,IAAI,CAACZ,MAAM,CAACM,UAAU,CAAC,CAACS,IAAI,CAAC,EAAE,CAAC;YAC3D,CAAC,EAAE,EAAE,GAAGF,CAAC,CAAC;YACVA,CAAC,EAAE;UACP;UACAH,UAAU,CAAC,MAAM;YACbD,OAAO,CAAC,CAAC;UACb,CAAC,EAAE,EAAE,GAAG,IAAI,CAACT,MAAM,CAACM,UAAU,CAAC,CAACC,MAAM,GAAG,IAAI,CAAC;QAClD,CACJ,CAAC;MACL,CAAC,MAAM;QACH,IAAI,CAACV,GAAG,CAACmB,SAAS,CAACC,GAAG,CAAC,WAAW,CAAC;MACvC;IAEJ;EACJ;AACJ;AAEA,eAAetB,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}